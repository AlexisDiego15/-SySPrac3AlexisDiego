
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Pr&aacute;ctica 3: Se&ntilde;ales continuas</title><meta name="generator" content="MATLAB 9.3"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2019-09-24"><meta name="DC.source" content="SySPrac3AlexisDiego.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>Pr&aacute;ctica 3: Se&ntilde;ales continuas</h1><!--introduction--><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Integrantes</a></li><li><a href="#3">Objetivos</a></li><li><a href="#5">Introduccion</a></li><li><a href="#8">Desarrollo</a></li><li><a href="#9">Problema 1</a></li><li><a href="#10">Problema 2</a></li><li><a href="#11">Problema 3</a></li><li><a href="#12">Problema 4</a></li><li><a href="#39">Problema 5</a></li><li><a href="#48">Problema 6</a></li><li><a href="#66">Problema 7</a></li><li><a href="#70">Referencias</a></li></ul></div><h2 id="1">Integrantes</h2><div><ul><li>Alvarez Garcia Elian Alexander</li><li>Diego Vertiz Alexis</li><li>Marquina Zendejas Victor</li><li>Mendivil Herrera Jesus Alejandro</li></ul></div><p>UPIITA IPN</p><p>Grupo: 2TV1</p><h2 id="3">Objetivos</h2><div><ul><li>Manipulaci&oacute;n b&aacute;sica de MATLAB</li><li>Gr&aacute;ficas de se&ntilde;ales reales y complejas continuas</li><li>Transformaci&oacute;n de se&ntilde;ales continuas (escalamientos y traslaciones)</li><li>Calculo de energ&iacute;a y potencia de se&ntilde;ales continuas</li></ul></div><h2 id="5">Introduccion</h2><p>Matlab es un programa de c&aacute;lculo num&eacute;rico orientado a matrices.  Matlab significa  "Matrix Laboratory" (laboratorio matricial). Fue creado por Cleve Moler en 1984, surgiendo la primera versi&oacute;n con la idea de emplear paquetes de subrutinas escritas en Fortran en los cursos de &aacute;lgebra lineal y an&aacute;lisis num&eacute;rico, sin necesidad de escribir programas en dicho lenguaje. El lenguaje de programaci&oacute;n M fue creado en 1970 para proporcionar un sencillo acceso al software de matrices LINPACK y EISPACK sin tener que usar Fortran. Actualmente Matlab es usado en una variedad de &aacute;reas de aplicaci&oacute;n incluyendo procesamiento de se&ntilde;ales e im&aacute;genes, dise&ntilde;o de sistemas de control, etc.</p><p>Octave es un lenguaje de alto nivel para realizar c&aacute;lculos num&eacute;ricos en el ordenador, es un programa capaz de interpretar este lenguaje y realizar los c&aacute;lculos. Octave ofrece una interfaz de usuario interactiva, orientada a l&iacute;nea de comandos, pero tambi&eacute;n puede ser utilizado en modo no interactivo, leyendo sus &oacute;rdenes de fichero. Otros programas de caracter&iacute;sticas similares, y hasta cierto punto compatibles, son el lenguaje R de la FSF, Scilab y el mismo Matlab. Estos dos &uacute;ltimos propietarios. Octave es software libre (bajo licencia GNU), lo que significa que se puede usar y redistribuir libremente, y que cualquiera puede ayudar para mejorarlo. Se puede tomar un breve curso introductoria a Matlab y Octave en el siguiente enlace: https://www.edx.org/course/matlab-octave-beginners-epflx-matlabeoctavebeginnersx</p><p>Python es un lenguaje de programaci&oacute;n que cuenta con estructuras de datos eficientes y de alto nivel y un enfoque simple pero efectivo a la programaci&oacute;n orientada a objetos. La sintaxis de Python y su tipado din&aacute;mico, junto con su naturaleza interpretada, hacen de &eacute;ste un lenguaje ideal para scripting y desarrollo r&aacute;pido de aplicaciones en diversas &aacute;reas y sobre la mayor&iacute;a de las plataformas. El int&eacute;rprete de Python y la extensa biblioteca est&aacute;ndar est&aacute;n a libre disposici&oacute;n en forma binaria y de c&oacute;digo fuente para las principales plataformas desde el sitio web de Python, https://www.python.org/, y puede distribuirse libremente.</p><h2 id="8">Desarrollo</h2><h2 id="9">Problema 1</h2><div><ol><li>Crea una funci&oacute;n que se llame <i>fun1</i> y reciba dos parametros <img src="SySPrac3AlexisDiego_eq08589834809570054062.png" alt="$\omega$"> y <img src="SySPrac3AlexisDiego_eq05508344529756732484.png" alt="$a$"> la funci&oacute;n debe regresar la evaluaci&oacute;n <img src="SySPrac3AlexisDiego_eq01407365636722940873.png" alt="$F(\omega)=a/(a^2+\omega^2)$">, esta funci&oacute;n debe trabajr con <img src="SySPrac3AlexisDiego_eq16064389548595522758.png" alt="$a\in R$"> y <img src="SySPrac3AlexisDiego_eq02576817051637404792.png" alt="$t\in  R^n$">. Debe mostrar su c&oacute;digo en el reporte (sin ejecutar).</li></ol></div><pre class="language-matlab"><span class="keyword">function</span> [f]=fun1(w,a)
    f=a./(a.^2+w.^2);
<span class="keyword">end</span>
</pre><h2 id="10">Problema 2</h2><div><ol><li>Construya una funci&oacute;n que gr&aacute;fique funciones de <img src="SySPrac3AlexisDiego_eq02145986785580767623.png" alt="$f:R\rightarrow R$"> en el formato de su elecci&oacute;n y pruebe su c&oacute;digo mostrando la gr&aacute;fica de <img src="SySPrac3AlexisDiego_eq04634431881849194213.png" alt="$F(\omega)$"> vs <img src="SySPrac3AlexisDiego_eq08589834809570054062.png" alt="$\omega$"> en el intervalo <img src="SySPrac3AlexisDiego_eq01169792831847459841.png" alt="$[-2,2]$"> para <img src="SySPrac3AlexisDiego_eq13016372792947090052.png" alt="$a=1$">, no debe incluir el c&oacute;digo, solo el uso de la funci&oacute;n para mostrar la gr&aacute;fica</li></ol></div><pre class="codeinput">  a=1;
  w=-2:0.001:2;
  Fw=a./(a.^2+w.^2);
  createfigure(w,fun1(w,a))
</pre><img vspace="5" hspace="5" src="SySPrac3AlexisDiego_01.png" alt=""> <h2 id="11">Problema 3</h2><p>XXXXXXXXXXXXXXXXXXXXXXXXXXXX</p><h2 id="12">Problema 4</h2><div><ol><li>Realiza las mismas operaciones que Lathi en las secciones M1.1 a M1.4  que se encuentra al final del cap&iacute;tulo 1 y antes de la secci&oacute;n de  problemas, cambie los <i>inline</i> por funciones anonimas</li></ol></div><p>Lathi M1.1 Funciones Anonimas</p><p>Considerando la se&ntilde;al <img src="SySPrac3AlexisDiego_eq09570209403238261006.png" alt="$f(t)=e^{-t}cos(2\pi t)$"> Tenemos la siguiente funci&oacute;n de forma anonima:</p><pre class="codeinput">f = @(t) exp(-t).*cos(2*pi*t);
</pre><p>Evaluando f(t) obtenemos</p><pre class="codeinput"> t=0;
 f(t)
</pre><pre class="codeoutput">
ans =

     1

</pre><p>Cuando t es un vector que solo tiene numeros enteros, es decir, [-2, -1, 0, 1, 2]</p><pre class="codeinput">t=(-2:2);
<span class="comment">% La salida es la siguiente</span>
f(t)
</pre><pre class="codeoutput">
ans =

    7.3891    2.7183    1.0000    0.3679    0.1353

</pre><p>Por lo que la grafica queda de la siguiente manera:</p><pre class="codeinput">clf;
plot(t, f(t));
xlabel(<span class="string">'t'</span>);
ylabel(<span class="string">'f(t)'</span>);
title(<span class="string">'Figura M1.1: f(t)=e^{-t}cos(2\pit) para t=(-2:2)'</span>);
grid;
</pre><img vspace="5" hspace="5" src="SySPrac3AlexisDiego_02.png" alt=""> <p>La ilustraci&oacute;n no corresponde con el comportamiento oscilatorio, ya que hacen falta m&aacute;s puntos, as&iacute; que ahora t tendra 100 puntos por oscilacion</p><pre class="codeinput">t=(-2:0.01:2);
<span class="comment">% Una vez definida t, graficamos de nuevo.</span>
clf;
plot(t, f(t));
xlabel(<span class="string">'t'</span>);
ylabel(<span class="string">'f(t)'</span>);
title(<span class="string">'Figura M1.2: f(t)=e^{-t}cos(2\pit) para t=(-2:0.01:2)'</span>);
grid;
</pre><img vspace="5" hspace="5" src="SySPrac3AlexisDiego_03.png" alt=""> <p>Lathi M1.2 Operadores relacionales y la funci&oacute;n escal&oacute;n</p><p>El escal&oacute;n unitario puede ser definido usando el operador &gt;=</p><pre class="codeinput">u = @(t) t &gt;= 0;
<span class="comment">% Usando t=(-2:2) para graficar u(t), tenemos:</span>
clf;
t=(-2:2);
plot(t, u(t));
xlabel(<span class="string">'t'</span>);
ylabel(<span class="string">'u(t)'</span>);
title(<span class="string">'Figura M1.3: u(t) para t=(-2:2)'</span>);
</pre><img vspace="5" hspace="5" src="SySPrac3AlexisDiego_04.png" alt=""> <p>Al existir solo enteros los puntos se unen entre s&iacute;, por lo que necesitamos m&aacute;s puntos de t y definir los limites para la grafica en el eje vertical y horizontal</p><pre class="codeinput">clf;
t=(-2:0.01:2);
plot(t,u(t));
xlabel(<span class="string">'t'</span>);
ylabel(<span class="string">'u(t)'</span>);
title(<span class="string">'Figura M1.4: u(t) para t=(-2:0.01:2) con modificacion de limites de ejes'</span>);
axis ([-2 2 -0.1 1.1]);
</pre><img vspace="5" hspace="5" src="SySPrac3AlexisDiego_05.png" alt=""> <p>Los operadores relacionales pueden ser combinados utilizando el AND, OR y NOT l&oacute;gicos: &amp;, | y ~, respectivamente. El pulso unitario p(t)=u(t)-u(t-1) se muestra a continuaci&oacute;n:</p><pre class="codeinput">p=@(t) (t&gt;=0)&amp;(t&lt;1);
t=(-1:0.01:2);
plot(t,p(t));
xlabel(<span class="string">'t'</span>);
ylabel(<span class="string">'p(t)=u(t)-u(t-1)'</span>);
title(<span class="string">'Figura M1.5: p(t)=u(t)-u(t-1) para -1&lt;t&lt;2'</span>);
axis([-1 2 -.1 1.1]);
</pre><img vspace="5" hspace="5" src="SySPrac3AlexisDiego_06.png" alt=""> <p>Lathi M1.3 Operadores relacionales y la funci&oacute;n escal&oacute;n</p><p>Considerando <img src="SySPrac3AlexisDiego_eq04480577728253239069.png" alt="$g(t)=f(t)=e^{-t}cos(2\pi t)u(t)$">, tenemos:</p><pre class="codeinput">g=@(t) exp(-t).*cos(2*pi*t).*u(t);
<span class="comment">% Una operaci&oacute;n combinada de escalamiento y desplazamiento puede ser</span>
<span class="comment">% representada por g(at+b), donde a y b son constantes.</span>
<span class="comment">% El valor "a" escala a la se&ntilde;al, y "b" la desplaza. Graficaremos g(2t +1)</span>
<span class="comment">% sobre (-2&lt;t&lt;2), con a=2, que es la se&ntilde;al comprimida en un factor de 2 y</span>
<span class="comment">% desplazada por una unidad hacia la izquierda.</span>
t=(-2:0.01:2);
plot(t, g(2*t+1));
xlabel(<span class="string">'t'</span>);
ylabel(<span class="string">'g(2t+1)'</span>);
title(<span class="string">'Figura M1.6: g(2t +1) sobre (-2&lt;t&lt;2)'</span>);
grid;
</pre><img vspace="5" hspace="5" src="SySPrac3AlexisDiego_07.png" alt=""> <p>Ahora consideraremos g(-t+1) sobre (-2&lt;t&lt;2),al ser a&lt;0, la onda ser&aacute; reflejada, y como b&gt;0 la onda se movera hacia la derecha</p><pre class="codeinput">plot(t, g(-t+1));
xlabel(<span class="string">'t'</span>);
ylabel(<span class="string">'g(-t+1)'</span>);
title(<span class="string">'Figura M1.7: g(-t+1) sobre (-2&lt;t&lt;2)'</span>);
grid;
</pre><img vspace="5" hspace="5" src="SySPrac3AlexisDiego_08.png" alt=""> <p>Ahora se graficar&aacute; h(t)= g(2t + 1)+g(?t + 1) sobre (?2&lt;t&lt;2)</p><pre class="codeinput">plot(t, g(2*t+1)+g(-t+1));
xlabel(<span class="string">'t'</span>);
ylabel(<span class="string">'h(t)'</span>);
title(<span class="string">'Figura M1.8: h(t)=g(2t+1)+g(?t+1) sobre (?2&lt;t&lt;2)'</span>);
grid;
</pre><img vspace="5" hspace="5" src="SySPrac3AlexisDiego_09.png" alt=""> <p>Lathi M1.4 Integraci&oacute;n num&eacute;rica y estimaci&oacute;n de la energ&iacute;a de la se&ntilde;al</p><p>Considerando la se&ntilde;al <img src="SySPrac3AlexisDiego_eq15069257353767425820.png" alt="$x(t)=e^{-t}(u(t)-u(t-1))$">. La energ&iacute;a de x(t) es representada como <img src="SySPrac3AlexisDiego_eq04265509633079195332.png" alt="$E_{x}=\int_{-\infty}^{\infty}|x(t)|^{2} dt=\int_{0}^{1}e^{-2t} dt$">. Realizando la integral, resulta <img src="SySPrac3AlexisDiego_eq08448384557788879611.png" alt="$E_{x}=\frac{1}{2} (1-e^{-2})\approx 0.4323$">. La integral de la energ&iacute;a puede tambi&eacute;n ser evaluada num&eacute;ricamente, mediante el m&eacute;todo de aproximaci&oacute;n rectangular: Evaluar la integral en puntos uniformemente separados por <img src="SySPrac3AlexisDiego_eq07651498126111630170.png" alt="$\Delta t$">, multiplicar cada evaluaci&oacute;n por <img src="SySPrac3AlexisDiego_eq07651498126111630170.png" alt="$\Delta t$"> para calcular las &aacute;reas de los rect&aacute;ngulos, y entonces sumar las &aacute;reas de todos los rect&aacute;ngulos. Para esto se crear&aacute; la siguiente funci&oacute;n:</p><pre class="codeinput">x=@(t) exp(-t).*((t&gt;=0)&amp;(t&lt;1));
</pre><p>y para <img src="SySPrac3AlexisDiego_eq10924356613126752321.png" alt="$\Delta t =0.01$"> un vector adecuado para el tiempo es:</p><pre class="codeinput">t=(0:0.01:1);
</pre><p>por lo que el resultado aproximado es</p><pre class="codeinput">E_x=sum(x(t).*x(t)*0.01)
</pre><pre class="codeoutput">
E_x =

    0.4367

</pre><p>El resultado tiene un error relativo casi de 1%. As&iacute; que, reduciendo <img src="SySPrac3AlexisDiego_eq07651498126111630170.png" alt="$\Delta t$"> la aproximaci&oacute;n es mejorada. Para <img src="SySPrac3AlexisDiego_eq01839625202798316333.png" alt="$\Delta t = 0.001$"> tenemos el siguiente resultado, ahora con un error relativo de 0.1%.</p><pre class="codeinput">t=(0:0.001:1);
E_x=sum(x(t).*x(t)*0.001)
</pre><pre class="codeoutput">
E_x =

    0.4328

</pre><p>Otra herramienta es la funci&oacute;n quad, que se puede utilizar como:</p><pre class="codeinput">x_squared=@(t) exp(-2*t).*((t&gt;=0)&amp;(t&lt;1));
E_x=quad(x_squared,0,1)
</pre><pre class="codeoutput">
E_x =

    0.4323

</pre><p>En este caso el error relativo es de -0.0026%.</p><p>Considere la se&ntilde;al g(t) definida en las secciones previas. La energ&iacute;a es expresada como <img src="SySPrac3AlexisDiego_eq11175002387816958077.png" alt="$E_{g} =\int_{0}^{\infty}e^{-2t}cos(2\pi t)^{2} dt$">. La respuesta se calcula de la siguiente manera</p><pre class="codeinput">g_squared=@(t) exp(-2*t).*(cos(2*pi*t).^2).*(t&gt;=0);
</pre><p>A pesar de que el l&iacute;mite de integraci&oacute;n superior es infinito, la exponencial decae y tiende a cero desde un n&uacute;mero no muy grande, por ejemplo, para t=100. Ahora, utilizaremos un l&iacute;mite superior de <img src="SySPrac3AlexisDiego_eq14204479301822374312.png" alt="$t=100$"> junto con un <img src="SySPrac3AlexisDiego_eq01486734845536595863.png" alt="$\Delta t=0.001$">:</p><pre class="codeinput">t=(0:0.001:100);
E_g=sum(g_squared(t)*0.001)
</pre><pre class="codeoutput">
E_g =

    0.2567

</pre><p>Y vamos a obtener una mejor aproximaci&oacute;n mediante la funci&oacute;n integral:</p><pre class="codeinput">E_g=integral(g_squared,0,100)
</pre><pre class="codeoutput">
E_g =

    0.2562

</pre><h2 id="39">Problema 5</h2><p>Resuelve el problema 1.2.2 usando las herramientas del paso anterior.</p><pre class="codeinput">clf;
x=@(t) (-t).*((t&gt;=-4)&amp;(t&lt;0))+(t).*((t&gt;=0)&amp;(t&lt;2));
t=(-10:0.01:10);
plot(t,x(t));
title(<span class="string">'x(t)'</span>);
axis([-7 7 -1 5]);
grid;
</pre><img vspace="5" hspace="5" src="SySPrac3AlexisDiego_10.png" alt=""> <p>Para la se&ntilde;al x(t) bosqueja:</p><div><ul><li>a. x(t-4)</li><li>b. x(t/1.5)</li><li>c. x(-t)</li><li>d. x(2t-4)</li><li>e. x(2-t)</li></ul></div><pre class="codeinput">plot(t,x(t-4));
title(<span class="string">'a. x(t-4)'</span>);
axis([-7 7 -1 5]);
</pre><img vspace="5" hspace="5" src="SySPrac3AlexisDiego_11.png" alt=""> <pre class="codeinput">plot(t,x(t./1.5));
title(<span class="string">'b. x(t/1.5)'</span>);
axis([-7 7 -1 5]);
</pre><img vspace="5" hspace="5" src="SySPrac3AlexisDiego_12.png" alt=""> <pre class="codeinput">plot(t,x(-t));
title(<span class="string">'c. x(-t)'</span>);
axis([-7 7 -1 5]);
</pre><img vspace="5" hspace="5" src="SySPrac3AlexisDiego_13.png" alt=""> <pre class="codeinput">plot(t,x(2.*t-4));
title(<span class="string">'d. x(2t-4)'</span>);
axis([-7 7 -1 5]);
</pre><img vspace="5" hspace="5" src="SySPrac3AlexisDiego_14.png" alt=""> <pre class="codeinput">plot(t,x(-t+2));
title(<span class="string">'e. x(2-t)'</span>);
axis([-7 7 -1 5]);
</pre><img vspace="5" hspace="5" src="SySPrac3AlexisDiego_15.png" alt=""> <h2 id="48">Problema 6</h2><div><ol><li>Escriba una funci&oacute;n que se llame <i>energia</i> que reciba como argumento una funci&oacute;n (anonima o simbolica) y que regrese el calculo de la energ&iacute;a, para esto puede resultar &uacute;til investigar las instrucciones <i>int</i> , <i>integral</i> Se presupone utilizar el c&oacute;digo solo con funciones de energia. Muestre el c&oacute;digo sin ejecutar, y posteriormente resuelva el problema 1.1.3</li></ol></div><p>1.1.3 a. Encuentra la energia del par de se&ntilde;ales x(t) y y(t). Bosqueja y encuentra la energia de las se&ntilde;ales x(t)+y(t) y x(t)-y(t).</p><p><img vspace="5" hspace="5" src="113pro.png" alt=""> </p><pre class="codeinput">clf;
ener=@(G,LimiteMenor,LimiteMayor) integral (G,LimiteMenor,LimiteMayor);
x=@(t)(abs(1).^2).*(t&gt;0).*(t&lt;=2);
y=@(t)(abs(1).^2).*(t&gt;0).*(t&lt;=1)+(abs(-1).^2).*(t&gt;1).*(t&lt;=2);
</pre><img vspace="5" hspace="5" src="SySPrac3AlexisDiego_16.png" alt=""> <p>a. Energia de x =</p><pre class="codeinput">ener(x,0,2)
</pre><pre class="codeoutput">
ans =

     2

</pre><p>a. Energia de y =</p><pre class="codeinput">ener(y,0,2)
</pre><pre class="codeoutput">
ans =

     2

</pre><p>a. Energia de x+y =</p><pre class="codeinput">ener(x,0,2)+ener(y,0,2)
</pre><pre class="codeoutput">
ans =

     4

</pre><p>a. Energia de x-y =</p><pre class="codeinput">ener(x,0,2)-ener(y,0,2)
</pre><pre class="codeoutput">
ans =

     0

</pre><pre class="codeinput">x=@(t)(sin(t).^2).*(t&gt;0).*(t&lt;=2*pi);
y=@(t)(abs(1).^2).*(t&gt;0).*(t&lt;=2*pi);
</pre><p>b. Energia de x =</p><pre class="codeinput">ener(x,0,2*pi)
</pre><pre class="codeoutput">
ans =

    3.1416

</pre><p>b. Energia de y =</p><pre class="codeinput">ener(y,0,2*pi)
</pre><pre class="codeoutput">
ans =

    6.2832

</pre><p>b. Energia de x+y =</p><pre class="codeinput">ener(x,0,2*pi)+ener(y,0,2*pi)
</pre><pre class="codeoutput">
ans =

    9.4248

</pre><p>b. Energia de x-y =</p><pre class="codeinput">ener(x,0,2*pi)-ener(y,0,2*pi)
</pre><pre class="codeoutput">
ans =

   -3.1416

</pre><pre class="codeinput">x=@(t)(sin(t).^2).*(t&gt;0).*(t&lt;=1*pi);
y=@(t)(abs(1).^2).*(t&gt;0).*(t&lt;=1*pi);
</pre><p>c. Energia de x =</p><pre class="codeinput">ener(x,0,1*pi)
</pre><pre class="codeoutput">
ans =

    1.5708

</pre><p>c. Energia de y =</p><pre class="codeinput">ener(y,0,1*pi)
</pre><pre class="codeoutput">
ans =

    3.1416

</pre><p>c. Energia de x+y =</p><pre class="codeinput">ener(x,0,1*pi)+ener(y,0,1*pi)
</pre><pre class="codeoutput">
ans =

    4.7124

</pre><p>c. Energia de x-y =</p><pre class="codeinput">ener(x,0,1*pi)-ener(y,0,1*pi)
</pre><pre class="codeoutput">
ans =

   -1.5708

</pre><h2 id="66">Problema 7</h2><div><ol><li>Escriba una funci&oacute;n que se llame <i>potencia</i> que reciba como argumento una funci&oacute;n (anonima o simbolica) y que regrese el calculo de la potencia para esto puede resultar &uacute;til investigar las instrucciones <i>int</i> , <i>integral</i> Se presupone utilizar el c&oacute;digo solo con funciones de potencia. Muestre el c&oacute;digo sin ejecutar, y posteriormente resuelva el problema 1.1.4</li></ol></div><p>Encuentra la potencia de la se&ntilde;al periodica x(t). Tambien encuentra las potencias y los valores RMS de:</p><div><ul><li>a. -x(t)</li><li>b. 2x(t)</li><li>c. cx(t)</li></ul></div><p><img vspace="5" hspace="5" src="114pro.png" alt=""> </p><h2 id="70">Referencias</h2><p>B. P. Lathi, Linear Systems and Signals, Second Edition, Oxford.</p><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2017b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% Práctica 3: Señales continuas
%% Integrantes
%
% * Alvarez Garcia Elian Alexander
% * Diego Vertiz Alexis
% * Marquina Zendejas Victor 
% * Mendivil Herrera Jesus Alejandro
%
% UPIITA IPN   
%
% Grupo: 2TV1 
%
%%
%% Objetivos
% *  Manipulación básica de MATLAB
% *  Gráficas de señales reales y complejas continuas
% *  Transformación de señales continuas (escalamientos y traslaciones)
% *  Calculo de energía y potencia de señales continuas
%%
%% Introduccion
% Matlab es un programa de cálculo numérico orientado a matrices.  Matlab significa  "Matrix Laboratory" (laboratorio matricial).
% Fue creado por Cleve Moler en 1984, surgiendo la primera versión con la idea de emplear paquetes de subrutinas escritas en 
% Fortran en los cursos de álgebra lineal y análisis numérico, sin necesidad de escribir programas en dicho lenguaje. 
% El lenguaje de programación M fue creado en 1970 para proporcionar un sencillo acceso al software de matrices LINPACK y
% EISPACK sin tener que usar Fortran. Actualmente Matlab es usado en una variedad de áreas de aplicación incluyendo procesamiento
% de señales e imágenes, diseño de sistemas de control, etc. 
%%
% Octave es un lenguaje de alto nivel para realizar cálculos numéricos en el ordenador, es un programa capaz de interpretar este
% lenguaje y realizar los cálculos. Octave ofrece una interfaz de usuario interactiva, orientada a línea de comandos, pero 
% también puede ser utilizado en modo no interactivo, leyendo sus órdenes de fichero. Otros programas de características 
% similares, y hasta cierto punto compatibles, son el lenguaje R de la FSF, Scilab y el mismo Matlab. Estos dos últimos 
% propietarios. Octave es software libre (bajo licencia GNU), lo que significa que se puede usar y redistribuir libremente,
% y que cualquiera puede ayudar para mejorarlo. Se puede tomar un breve curso introductoria a Matlab y Octave en el siguiente
% enlace: https://www.edx.org/course/matlab-octave-beginners-epflx-matlabeoctavebeginnersx
%% 
% Python es un lenguaje de programación que cuenta con estructuras de datos eficientes y de alto nivel y un enfoque simple 
% pero efectivo a la programación orientada a objetos. La sintaxis de Python y su tipado dinámico, junto con su naturaleza 
% interpretada, hacen de éste un lenguaje ideal para scripting y desarrollo rápido de aplicaciones en diversas áreas y sobre
% la mayoría de las plataformas. El intérprete de Python y la extensa biblioteca estándar están a libre disposición en forma
% binaria y de código fuente para las principales plataformas desde el sitio web de Python, https://www.python.org/, 
% y puede distribuirse libremente. 
%
%
%% Desarrollo
%
%% Problema 1
%
% # Crea una función que se llame _fun1_ y reciba dos parametros $\omega$ y 
% $a$ la función debe regresar la evaluación $F(\omega)=a/(a^2+\omega^2)$,
% esta función debe trabajr con $a\in R$ y $t\in  R^n$. Debe
% mostrar su código en el reporte (sin ejecutar).
%
%
%   function [f]=fun1(w,a) 
%       f=a./(a.^2+w.^2);  
%   end
% 
%% Problema 2
% # Construya una función que gráfique funciones de
% $f:R\rightarrow R$ en el formato de su elección y pruebe
% su código mostrando la gráfica de $F(\omega)$ vs $\omega$ en el intervalo
% $[-2,2]$ para $a=1$, no debe
% incluir el código, solo el uso de la función para mostrar la gráfica
%
  a=1;
  w=-2:0.001:2; 
  Fw=a./(a.^2+w.^2);
  createfigure(w,fun1(w,a))
  
%% Problema 3
% XXXXXXXXXXXXXXXXXXXXXXXXXXXX
%% Problema 4
% # Realiza las mismas operaciones que Lathi en las secciones M1.1 a M1.4
%  que se encuentra al final del capítulo 1 y antes de la sección de
%  problemas, cambie los _inline_ por funciones anonimas
%
% Lathi M1.1 Funciones Anonimas
%%
% Considerando la señal $f(t)=e^{-t}cos(2\pi t)$
% Tenemos la siguiente función de forma anonima:
%
f = @(t) exp(-t).*cos(2*pi*t);
%%
% Evaluando f(t) obtenemos
 t=0;
 f(t)
%%
% Cuando t es un vector que solo tiene numeros enteros, es decir, [-2, -1, 0, 1, 2]
t=(-2:2);
% La salida es la siguiente
f(t)
%%
% Por lo que la grafica queda de la siguiente manera:
clf;
plot(t, f(t));
xlabel('t');
ylabel('f(t)');
title('Figura M1.1: f(t)=e^{-t}cos(2\pit) para t=(-2:2)');
grid;
%%
% La ilustración no corresponde con el comportamiento oscilatorio, ya que
% hacen falta más puntos, así que ahora t tendra 100 puntos por oscilacion
t=(-2:0.01:2);
% Una vez definida t, graficamos de nuevo.
clf;
plot(t, f(t));
xlabel('t');
ylabel('f(t)');
title('Figura M1.2: f(t)=e^{-t}cos(2\pit) para t=(-2:0.01:2)');
grid;
%%
% Lathi M1.2 Operadores relacionales y la función escalón
%%
% El escalón unitario puede ser definido usando el operador >=
u = @(t) t >= 0;
% Usando t=(-2:2) para graficar u(t), tenemos:
clf;
t=(-2:2);
plot(t, u(t));
xlabel('t');
ylabel('u(t)');
title('Figura M1.3: u(t) para t=(-2:2)');
%%
% Al existir solo enteros los puntos se unen entre sí, por lo que
% necesitamos más puntos de t y definir los limites para la grafica en el
% eje vertical y horizontal
clf;
t=(-2:0.01:2);
plot(t,u(t));
xlabel('t');
ylabel('u(t)');
title('Figura M1.4: u(t) para t=(-2:0.01:2) con modificacion de limites de ejes');
axis ([-2 2 -0.1 1.1]);
%%
% Los operadores relacionales pueden ser combinados utilizando el AND, OR y 
% NOT lógicos: &, | y ~, respectivamente. El pulso unitario p(t)=u(t)-u(t-1)
% se muestra a continuación:
p=@(t) (t>=0)&(t<1);
t=(-1:0.01:2);
plot(t,p(t));
xlabel('t'); 
ylabel('p(t)=u(t)-u(t-1)');
title('Figura M1.5: p(t)=u(t)-u(t-1) para -1<t<2');
axis([-1 2 -.1 1.1]);
%%
% Lathi M1.3 Operadores relacionales y la función escalón
%%
% Considerando $g(t)=f(t)=e^{-t}cos(2\pi t)u(t)$, tenemos:
g=@(t) exp(-t).*cos(2*pi*t).*u(t);
% Una operación combinada de escalamiento y desplazamiento puede ser 
% representada por g(at+b), donde a y b son constantes.
% El valor "a" escala a la señal, y "b" la desplaza. Graficaremos g(2t +1) 
% sobre (-2<t<2), con a=2, que es la señal comprimida en un factor de 2 y 
% desplazada por una unidad hacia la izquierda.
t=(-2:0.01:2);
plot(t, g(2*t+1));
xlabel('t');
ylabel('g(2t+1)'); 
title('Figura M1.6: g(2t +1) sobre (-2<t<2)');
grid;
%%
% Ahora consideraremos g(-t+1) sobre (-2<t<2),al ser a<0, la onda será
% reflejada, y como b>0 la onda se movera hacia la derecha
plot(t, g(-t+1));
xlabel('t'); 
ylabel('g(-t+1)'); 
title('Figura M1.7: g(-t+1) sobre (-2<t<2)');
grid;
%%
% Ahora se graficará h(t)= g(2t + 1)+g(?t + 1) sobre (?2<t<2)
plot(t, g(2*t+1)+g(-t+1));
xlabel('t'); 
ylabel('h(t)'); 
title('Figura M1.8: h(t)=g(2t+1)+g(?t+1) sobre (?2<t<2)');
grid;
%%
% Lathi M1.4 Integración numérica y estimación de la energía de la señal
%%
% Considerando la señal $x(t)=e^{-t}(u(t)-u(t-1))$. La energía de x(t) es
% representada como $E_{x}=\int_{-\infty}^{\infty}|x(t)|^{2}
% dt=\int_{0}^{1}e^{-2t} dt$. Realizando la integral, resulta
% $E_{x}=\frac{1}{2} (1-e^{-2})\approx 0.4323$. La integral de la energía
% puede también ser evaluada numéricamente, mediante el método de
% aproximación rectangular: Evaluar la integral en puntos uniformemente
% separados por $\Delta t$, multiplicar cada evaluación por $\Delta t$ para
% calcular las áreas de los rectángulos, y entonces sumar las áreas de
% todos los rectángulos. Para esto se creará la siguiente función:
%%
x=@(t) exp(-t).*((t>=0)&(t<1));
%%
% y para $\Delta t =0.01$ un vector adecuado para el tiempo es:
%%
t=(0:0.01:1);
%%
% por lo que el resultado aproximado es
%%
E_x=sum(x(t).*x(t)*0.01)
%% 
% El resultado tiene un error relativo casi de 1%. Así que, reduciendo
% $\Delta t$ la aproximación es mejorada. Para $\Delta t = 0.001$ tenemos 
% el siguiente resultado, ahora con un error relativo de 0.1%.
t=(0:0.001:1);
E_x=sum(x(t).*x(t)*0.001)
%%
% Otra herramienta es la función quad, que se puede utilizar como:
x_squared=@(t) exp(-2*t).*((t>=0)&(t<1));
E_x=quad(x_squared,0,1)
%%
% En este caso el error relativo es de -0.0026%.
%%
% Considere la señal g(t) definida en las secciones previas.
% La energía es expresada como $E_{g} =\int_{0}^{\infty}e^{-2t}cos(2\pi
% t)^{2} dt$. La respuesta se calcula de la siguiente manera
g_squared=@(t) exp(-2*t).*(cos(2*pi*t).^2).*(t>=0);
%%
% A pesar de que el límite de integración superior es infinito, la exponencial
% decae y tiende a cero desde un número no muy grande, por ejemplo, para
% t=100. Ahora, utilizaremos un límite superior de $t=100$ junto con un
% $\Delta t=0.001$:
t=(0:0.001:100);
E_g=sum(g_squared(t)*0.001)
%%
% Y vamos a obtener una mejor aproximación mediante la función integral:
E_g=integral(g_squared,0,100)

%% Problema 5
% Resuelve el problema 1.2.2 usando las herramientas del paso anterior.
%%
clf;
x=@(t) (-t).*((t>=-4)&(t<0))+(t).*((t>=0)&(t<2));
t=(-10:0.01:10);
plot(t,x(t));
title('x(t)');
axis([-7 7 -1 5]);
grid;
%%
% Para la señal x(t) bosqueja:
%%
% * a. x(t-4)
% * b. x(t/1.5)
% * c. x(-t)
% * d. x(2t-4)
% * e. x(2-t)
%%
plot(t,x(t-4));
title('a. x(t-4)');
axis([-7 7 -1 5]);
%%
plot(t,x(t./1.5));
title('b. x(t/1.5)');
axis([-7 7 -1 5]);
%%
plot(t,x(-t));
title('c. x(-t)');
axis([-7 7 -1 5]);
%%
plot(t,x(2.*t-4));
title('d. x(2t-4)');
axis([-7 7 -1 5]);
%%
plot(t,x(-t+2));
title('e. x(2-t)');
axis([-7 7 -1 5]);
%% Problema 6
% # Escriba una función que se llame _energia_ que reciba como argumento
% una función (anonima o simbolica) y que regrese el calculo de la energía,
% para esto puede resultar útil investigar las instrucciones _int_ , _integral_
% Se presupone utilizar el código solo con funciones de energia. Muestre
% el código sin ejecutar, y posteriormente resuelva el problema 1.1.3
%%
% 1.1.3 a. Encuentra la energia del par de señales x(t) y y(t). Bosqueja y
% encuentra la energia de las señales x(t)+y(t) y x(t)-y(t).
%%
% 
% <<113pro.png>>
% 
%%
clf;
ener=@(G,LimiteMenor,LimiteMayor) integral (G,LimiteMenor,LimiteMayor);
x=@(t)(abs(1).^2).*(t>0).*(t<=2);
y=@(t)(abs(1).^2).*(t>0).*(t<=1)+(abs(-1).^2).*(t>1).*(t<=2);
%%
% a. Energia de x =
ener(x,0,2)
%%
% a. Energia de y =
ener(y,0,2)
%%
% a. Energia de x+y =
ener(x,0,2)+ener(y,0,2)
%%
% a. Energia de x-y =
ener(x,0,2)-ener(y,0,2)
%%
x=@(t)(sin(t).^2).*(t>0).*(t<=2*pi);
y=@(t)(abs(1).^2).*(t>0).*(t<=2*pi);
%%
% b. Energia de x =
ener(x,0,2*pi)
%%
% b. Energia de y =
ener(y,0,2*pi)
%%
% b. Energia de x+y =
ener(x,0,2*pi)+ener(y,0,2*pi)
%%
% b. Energia de x-y =
ener(x,0,2*pi)-ener(y,0,2*pi)
%%
x=@(t)(sin(t).^2).*(t>0).*(t<=1*pi);
y=@(t)(abs(1).^2).*(t>0).*(t<=1*pi);
%%
% c. Energia de x =
ener(x,0,1*pi)
%%
% c. Energia de y =
ener(y,0,1*pi)
%%
% c. Energia de x+y =
ener(x,0,1*pi)+ener(y,0,1*pi)
%%
% c. Energia de x-y =
ener(x,0,1*pi)-ener(y,0,1*pi)
%% Problema 7
% # Escriba una función que se llame _potencia_ que reciba como argumento
% una función (anonima o simbolica) y que regrese el calculo de la potencia
% para esto puede resultar útil investigar las instrucciones _int_ , _integral_
% Se presupone utilizar el código solo con funciones de potencia. Muestre
% el código sin ejecutar, y posteriormente resuelva el problema 1.1.4
%%
% Encuentra la potencia de la señal periodica x(t). Tambien encuentra las
% potencias y los valores RMS de:
%%
% * a. -x(t)
% * b. 2x(t)
% * c. cx(t)
%%
% 
% <<114pro.png>>
% 
%% Referencias
% B. P. Lathi, Linear Systems and Signals, Second Edition, Oxford.
##### SOURCE END #####
--></body></html>